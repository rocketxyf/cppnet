// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto

#ifndef PROTOBUF_rpc_2eproto__INCLUDED
#define PROTOBUF_rpc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace rpcproto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rpc_2eproto();
void protobuf_AssignDesc_rpc_2eproto();
void protobuf_ShutdownFile_rpc_2eproto();

class rpc;
class request;
class error;
class response;

enum erpc {
  REQUESST = 0,
  PUSH = 1,
  RESPONSE = 2
};
bool erpc_IsValid(int value);
const erpc erpc_MIN = REQUESST;
const erpc erpc_MAX = RESPONSE;
const int erpc_ARRAYSIZE = erpc_MAX + 1;

const ::google::protobuf::EnumDescriptor* erpc_descriptor();
inline const ::std::string& erpc_Name(erpc value) {
  return ::google::protobuf::internal::NameOfEnum(
    erpc_descriptor(), value);
}
inline bool erpc_Parse(
    const ::std::string& name, erpc* value) {
  return ::google::protobuf::internal::ParseNamedEnum<erpc>(
    erpc_descriptor(), name, value);
}
// ===================================================================

class rpc : public ::google::protobuf::Message {
 public:
  rpc();
  virtual ~rpc();
  
  rpc(const rpc& from);
  
  inline rpc& operator=(const rpc& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const rpc& default_instance();
  
  void Swap(rpc* other);
  
  // implements Message ----------------------------------------------
  
  rpc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rpc& from);
  void MergeFrom(const rpc& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .rpcproto.erpc type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline rpcproto::erpc type() const;
  inline void set_type(rpcproto::erpc value);
  
  // optional .rpcproto.request req = 2;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 2;
  inline const ::rpcproto::request& req() const;
  inline ::rpcproto::request* mutable_req();
  inline ::rpcproto::request* release_req();
  
  // optional .rpcproto.response rep = 3;
  inline bool has_rep() const;
  inline void clear_rep();
  static const int kRepFieldNumber = 3;
  inline const ::rpcproto::response& rep() const;
  inline ::rpcproto::response* mutable_rep();
  inline ::rpcproto::response* release_rep();
  
  // @@protoc_insertion_point(class_scope:rpcproto.rpc)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_rep();
  inline void clear_has_rep();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::rpcproto::request* req_;
  ::rpcproto::response* rep_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  void InitAsDefaultInstance();
  static rpc* default_instance_;
};
// -------------------------------------------------------------------

class request : public ::google::protobuf::Message {
 public:
  request();
  virtual ~request();
  
  request(const request& from);
  
  inline request& operator=(const request& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const request& default_instance();
  
  void Swap(request* other);
  
  // implements Message ----------------------------------------------
  
  request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const request& from);
  void MergeFrom(const request& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required int32 opcode = 3;
  inline bool has_opcode() const;
  inline void clear_opcode();
  static const int kOpcodeFieldNumber = 3;
  inline ::google::protobuf::int32 opcode() const;
  inline void set_opcode(::google::protobuf::int32 value);
  
  // optional bytes msg = 4;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 4;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // @@protoc_insertion_point(class_scope:rpcproto.request)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_opcode();
  inline void clear_has_opcode();
  inline void set_has_msg();
  inline void clear_has_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 opcode_;
  ::std::string* msg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  void InitAsDefaultInstance();
  static request* default_instance_;
};
// -------------------------------------------------------------------

class error : public ::google::protobuf::Message {
 public:
  error();
  virtual ~error();
  
  error(const error& from);
  
  inline error& operator=(const error& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const error& default_instance();
  
  void Swap(error* other);
  
  // implements Message ----------------------------------------------
  
  error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const error& from);
  void MergeFrom(const error& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);
  
  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  
  // @@protoc_insertion_point(class_scope:rpcproto.error)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_text();
  inline void clear_has_text();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* text_;
  ::google::protobuf::int32 code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  void InitAsDefaultInstance();
  static error* default_instance_;
};
// -------------------------------------------------------------------

class response : public ::google::protobuf::Message {
 public:
  response();
  virtual ~response();
  
  response(const response& from);
  
  inline response& operator=(const response& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const response& default_instance();
  
  void Swap(response* other);
  
  // implements Message ----------------------------------------------
  
  response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const response& from);
  void MergeFrom(const response& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional bytes msg = 3;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 3;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // optional .rpcproto.error error = 4;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 4;
  inline const ::rpcproto::error& error() const;
  inline ::rpcproto::error* mutable_error();
  inline ::rpcproto::error* release_error();
  
  // @@protoc_insertion_point(class_scope:rpcproto.response)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* msg_;
  ::rpcproto::error* error_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  void InitAsDefaultInstance();
  static response* default_instance_;
};
// ===================================================================


// ===================================================================

// rpc

// required .rpcproto.erpc type = 1;
inline bool rpc::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rpc::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rpc::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rpc::clear_type() {
  type_ = 0;
  set_changed();
  clear_has_type();
}
inline rpcproto::erpc rpc::type() const {
  return static_cast< rpcproto::erpc >(type_);
}
inline void rpc::set_type(rpcproto::erpc value) {
  GOOGLE_DCHECK(rpcproto::erpc_IsValid(value));
  set_has_type();
  set_changed();
  type_ = value;
}

// optional .rpcproto.request req = 2;
inline bool rpc::has_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rpc::set_has_req() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rpc::clear_has_req() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rpc::clear_req() {
  if (req_ != NULL) req_->::rpcproto::request::Clear();
  set_changed();
  clear_has_req();
}
inline const ::rpcproto::request& rpc::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::rpcproto::request* rpc::mutable_req() {
  set_has_req();
  set_changed();
  if (req_ == NULL) req_ = new ::rpcproto::request;
  return req_;
}
inline ::rpcproto::request* rpc::release_req() {
  clear_has_req();
  set_changed();
  ::rpcproto::request* temp = req_;
  req_ = NULL;
  return temp;
}

// optional .rpcproto.response rep = 3;
inline bool rpc::has_rep() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void rpc::set_has_rep() {
  _has_bits_[0] |= 0x00000004u;
}
inline void rpc::clear_has_rep() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void rpc::clear_rep() {
  if (rep_ != NULL) rep_->::rpcproto::response::Clear();
  set_changed();
  clear_has_rep();
}
inline const ::rpcproto::response& rpc::rep() const {
  return rep_ != NULL ? *rep_ : *default_instance_->rep_;
}
inline ::rpcproto::response* rpc::mutable_rep() {
  set_has_rep();
  set_changed();
  if (rep_ == NULL) rep_ = new ::rpcproto::response;
  return rep_;
}
inline ::rpcproto::response* rpc::release_rep() {
  clear_has_rep();
  set_changed();
  ::rpcproto::response* temp = rep_;
  rep_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// request

// required string name = 1;
inline bool request::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void request::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void request::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void request::clear_name() {
  if (name_ != 0) {
    name_->clear();
  }
  set_changed();
  clear_has_name();
}
inline const ::std::string& request::name() const {
  if (name_ == 0) {
    return ::google::protobuf::internal::kEmptyString;
  }
  return *name_;
}
inline void request::set_name(const ::std::string& value) {
  set_has_name();
  set_changed();
  if (name_ == 0) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void request::set_name(const char* value) {
  set_has_name();
  set_changed();
  if (name_ == 0) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void request::set_name(const char* value, size_t size) {
  set_has_name();
  set_changed();
  if (name_ == 0) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* request::mutable_name() {
  set_has_name();
  set_changed();
  if (name_ == 0) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* request::release_name() {
  clear_has_name();
  set_changed();
  if (name_ == 0) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = 0;
    return temp;
  }
}

// required int32 id = 2;
inline bool request::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void request::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void request::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void request::clear_id() {
  id_ = 0;
  set_changed();
  clear_has_id();
}
inline ::google::protobuf::int32 request::id() const {
  return id_;
}
inline void request::set_id(::google::protobuf::int32 value) {
  set_has_id();
  set_changed();
  id_ = value;
}

// required int32 opcode = 3;
inline bool request::has_opcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void request::set_has_opcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void request::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void request::clear_opcode() {
  opcode_ = 0;
  set_changed();
  clear_has_opcode();
}
inline ::google::protobuf::int32 request::opcode() const {
  return opcode_;
}
inline void request::set_opcode(::google::protobuf::int32 value) {
  set_has_opcode();
  set_changed();
  opcode_ = value;
}

// optional bytes msg = 4;
inline bool request::has_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void request::set_has_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void request::clear_has_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void request::clear_msg() {
  if (msg_ != 0) {
    msg_->clear();
  }
  set_changed();
  clear_has_msg();
}
inline const ::std::string& request::msg() const {
  if (msg_ == 0) {
    return ::google::protobuf::internal::kEmptyString;
  }
  return *msg_;
}
inline void request::set_msg(const ::std::string& value) {
  set_has_msg();
  set_changed();
  if (msg_ == 0) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void request::set_msg(const char* value) {
  set_has_msg();
  set_changed();
  if (msg_ == 0) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void request::set_msg(const void* value, size_t size) {
  set_has_msg();
  set_changed();
  if (msg_ == 0) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* request::mutable_msg() {
  set_has_msg();
  set_changed();
  if (msg_ == 0) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* request::release_msg() {
  clear_has_msg();
  set_changed();
  if (msg_ == 0) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = 0;
    return temp;
  }
}

// -------------------------------------------------------------------

// error

// required int32 code = 1;
inline bool error::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void error::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void error::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void error::clear_code() {
  code_ = 0;
  set_changed();
  clear_has_code();
}
inline ::google::protobuf::int32 error::code() const {
  return code_;
}
inline void error::set_code(::google::protobuf::int32 value) {
  set_has_code();
  set_changed();
  code_ = value;
}

// optional string text = 2;
inline bool error::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void error::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void error::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void error::clear_text() {
  if (text_ != 0) {
    text_->clear();
  }
  set_changed();
  clear_has_text();
}
inline const ::std::string& error::text() const {
  if (text_ == 0) {
    return ::google::protobuf::internal::kEmptyString;
  }
  return *text_;
}
inline void error::set_text(const ::std::string& value) {
  set_has_text();
  set_changed();
  if (text_ == 0) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void error::set_text(const char* value) {
  set_has_text();
  set_changed();
  if (text_ == 0) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void error::set_text(const char* value, size_t size) {
  set_has_text();
  set_changed();
  if (text_ == 0) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* error::mutable_text() {
  set_has_text();
  set_changed();
  if (text_ == 0) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* error::release_text() {
  clear_has_text();
  set_changed();
  if (text_ == 0) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = 0;
    return temp;
  }
}

// -------------------------------------------------------------------

// response

// required string name = 1;
inline bool response::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void response::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void response::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void response::clear_name() {
  if (name_ != 0) {
    name_->clear();
  }
  set_changed();
  clear_has_name();
}
inline const ::std::string& response::name() const {
  if (name_ == 0) {
    return ::google::protobuf::internal::kEmptyString;
  }
  return *name_;
}
inline void response::set_name(const ::std::string& value) {
  set_has_name();
  set_changed();
  if (name_ == 0) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void response::set_name(const char* value) {
  set_has_name();
  set_changed();
  if (name_ == 0) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void response::set_name(const char* value, size_t size) {
  set_has_name();
  set_changed();
  if (name_ == 0) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* response::mutable_name() {
  set_has_name();
  set_changed();
  if (name_ == 0) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* response::release_name() {
  clear_has_name();
  set_changed();
  if (name_ == 0) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = 0;
    return temp;
  }
}

// required int32 id = 2;
inline bool response::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void response::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void response::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void response::clear_id() {
  id_ = 0;
  set_changed();
  clear_has_id();
}
inline ::google::protobuf::int32 response::id() const {
  return id_;
}
inline void response::set_id(::google::protobuf::int32 value) {
  set_has_id();
  set_changed();
  id_ = value;
}

// optional bytes msg = 3;
inline bool response::has_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void response::set_has_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void response::clear_has_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void response::clear_msg() {
  if (msg_ != 0) {
    msg_->clear();
  }
  set_changed();
  clear_has_msg();
}
inline const ::std::string& response::msg() const {
  if (msg_ == 0) {
    return ::google::protobuf::internal::kEmptyString;
  }
  return *msg_;
}
inline void response::set_msg(const ::std::string& value) {
  set_has_msg();
  set_changed();
  if (msg_ == 0) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void response::set_msg(const char* value) {
  set_has_msg();
  set_changed();
  if (msg_ == 0) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void response::set_msg(const void* value, size_t size) {
  set_has_msg();
  set_changed();
  if (msg_ == 0) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* response::mutable_msg() {
  set_has_msg();
  set_changed();
  if (msg_ == 0) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* response::release_msg() {
  clear_has_msg();
  set_changed();
  if (msg_ == 0) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = 0;
    return temp;
  }
}

// optional .rpcproto.error error = 4;
inline bool response::has_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void response::set_has_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void response::clear_has_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void response::clear_error() {
  if (error_ != NULL) error_->::rpcproto::error::Clear();
  set_changed();
  clear_has_error();
}
inline const ::rpcproto::error& response::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::rpcproto::error* response::mutable_error() {
  set_has_error();
  set_changed();
  if (error_ == NULL) error_ = new ::rpcproto::error;
  return error_;
}
inline ::rpcproto::error* response::release_error() {
  clear_has_error();
  set_changed();
  ::rpcproto::error* temp = error_;
  error_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpcproto

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< rpcproto::erpc>() {
  return rpcproto::erpc_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rpc_2eproto__INCLUDED
